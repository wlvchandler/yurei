module Oni16 (
    input clk,            // Clock signal
    input reset,          // Reset signal
    input [15:0] instruction,  // 16-bit instruction input
    output reg [7:0] A, B, C, D, I, J, SP, PC, FLAGS  // 8-bit registers
);

// State enumeration
typedef enum {IDLE, FETCH, EXECUTE} state_t;

// State registers
reg [1:0] state, next_state;

// Instruction fields
reg [15:0] opcode;
reg [7:0] operand1, operand2;

// Memory interface signals
wire [15:0] memory_address;
wire [7:0] memory_data_in;
wire [7:0] memory_data_out;
wire memory_write_enable;

// Stack limits
reg [15:0] stack_top = 16'h9FFF; // top of stack (highest address)
reg [15:0] stack_bottom = 16'h9000; // bottom of stack (lowest address)


// Main state machine
always @(posedge clk or posedge reset) begin
    if (reset) begin
        state <= IDLE;
        A <= 8'b0;
        // Initialize other registers...
    end else begin
        state <= next_state;

        // Fetch & Decode
        if (next_state == FETCH) begin
            opcode = instruction[15:8];
            operand1 = instruction[7:4];
            operand2 = instruction[3:0];
        end
        
        // Execute
        if (next_state == EXECUTE) begin
            case (opcode)
                16'h0000: begin /* NOP */ end
                16'h0001: begin /* HALT */ end
                16'h000A: begin /* LOAD */ end
                16'h000D: begin // PUSH
                    if (SP > stack_bottom) begin // Check for stack underflow
                        SP <= SP - 1; // Decrease stack pointer (stack grows down from 0x9fff)
                        memory_address <= SP;
                        memory_data_in <= operand1; // Assuming operand1 contains the data to push
                        memory_write_enable <= 1;
                    end else begin
                        // Handle stack underflow
                    end
                end
                16'h000E: begin // POP
                    if (SP < stack_top) begin // stack overflow check
                        memory_address <= SP;
                        memory_write_enable <= 0;
                        operand1 <= memory_data_out; // Assuming operand1 receives the data popped
                        SP <= SP + 1; // Increase stack pointer (stack grows downwards)
                    end else begin
                        // Handle stack overflow 
                    end
                end
                default: begin /* Invalid opcode */ end
            endcase
        end
    end
end

// Next state logic
always @(*) begin
    case (state)
        IDLE:
            next_state = FETCH;
        FETCH:
            next_state = EXECUTE;
        EXECUTE:
            next_state = IDLE;
    endcase
end

endmodule
